//! # ZK Proof Validation
//!
//! This module implements production-grade ZK proof validation for VEFAS proofs
//! generated by RISC0 and SP1 zkVM guest programs.
//!
//! ## Architecture
//!
//! The ZK Proof Validator provides:
//! 1. **RISC0 Proof Validation**: Validates RISC0 receipts and extracts claims
//! 2. **SP1 Proof Validation**: Validates SP1 proofs and extracts claims
//! 3. **Merkle Proof Validation**: Validates Merkle proofs for selective disclosure
//! 4. **Claim Verification**: Verifies extracted claims against bundle data
//!
//! ## Security Model
//!
//! The validator operates under the assumption that:
//! - ZK proofs are cryptographically sound (RISC0/SP1 security)
//! - Merkle proofs provide selective disclosure guarantees
//! - Claims extracted from proofs are binding commitments
//! - Bundle data matches the commitments in the proofs

use crate::error::{VefasNodeError, VefasNodeResult};
use serde::{Deserialize, Serialize};
use std::time::Instant;
use tracing::{debug, error, info, instrument, warn};
use vefas_types::{
    VefasCanonicalBundle, VefasProofClaim,
};

/// ZK proof validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkProofValidationResult {
    /// Whether the proof is valid
    pub is_valid: bool,
    /// Extracted claim from the proof
    pub claim: Option<VefasProofClaim>,
    /// Validation metadata
    pub metadata: ZkProofValidationMetadata,
    /// Validation errors (if any)
    pub errors: Vec<String>,
}

/// ZK proof validation metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkProofValidationMetadata {
    /// Platform used for the proof (risc0, sp1)
    pub platform: String,
    /// Time taken to validate the proof in milliseconds
    pub validation_time_ms: u64,
    /// Whether Merkle proofs were validated
    pub merkle_proofs_validated: bool,
    /// Number of Merkle proofs validated
    pub merkle_proofs_count: usize,
    /// Whether claim extraction was successful
    pub claim_extraction_successful: bool,
    /// Whether claim verification was successful
    pub claim_verification_successful: bool,
}

/// Verifier Service for VEFAS proofs
pub struct VerifierService {
    /// RISC0 prover for proof validation
    #[cfg(feature = "risc0")]
    risc0_prover: Option<vefas_risc0::VefasRisc0Prover>,
    /// SP1 prover for proof validation
    #[cfg(feature = "sp1")]
    sp1_prover: Option<vefas_sp1::VefasSp1Prover>,
}

impl VerifierService {
    /// Create a new ZK proof validator
    pub fn new() -> Self {
        Self {
            #[cfg(feature = "risc0")]
            risc0_prover: None,
            #[cfg(feature = "sp1")]
            sp1_prover: None,
        }
    }

    /// Initialize RISC0 prover
    #[cfg(feature = "risc0")]
    pub fn with_risc0_prover(mut self, prover: vefas_risc0::VefasRisc0Prover) -> Self {
        self.risc0_prover = Some(prover);
        self
    }

    /// Initialize SP1 prover
    #[cfg(feature = "sp1")]
    pub fn with_sp1_prover(mut self, prover: vefas_sp1::VefasSp1Prover) -> Self {
        self.sp1_prover = Some(prover);
        self
    }

    /// Validate a ZK proof and extract the claim
    #[instrument(skip(self, proof_data), fields(platform = %platform))]
    pub async fn validate_zk_proof(
        &self,
        proof_data: &[u8],
        platform: &str,
        bundle: &VefasCanonicalBundle,
    ) -> VefasNodeResult<ZkProofValidationResult> {
        let start_time = Instant::now();
        let mut errors = Vec::new();
        let mut metadata = ZkProofValidationMetadata {
            platform: platform.to_string(),
            validation_time_ms: 0,
            merkle_proofs_validated: false,
            merkle_proofs_count: 0,
            claim_extraction_successful: false,
            claim_verification_successful: false,
        };

        info!("Starting ZK proof validation for platform: {}", platform);

        // Validate proof based on platform
        let claim = match platform {
            #[cfg(feature = "risc0")]
            "risc0" => {
                self.validate_risc0_proof(proof_data, bundle, &mut metadata, &mut errors)
                    .await?
            }
            #[cfg(feature = "sp1")]
            "sp1" => {
                self.validate_sp1_proof(proof_data, bundle, &mut metadata, &mut errors)
                    .await?
            }
            _ => {
                let error_msg = format!("Unsupported platform: {}", platform);
                error!("{}", error_msg);
                errors.push(error_msg);
                return Ok(ZkProofValidationResult {
                    is_valid: false,
                    claim: None,
                    metadata,
                    errors,
                });
            }
        };

        // Validate Merkle proofs if claim extraction was successful
        if let Some(ref claim) = claim {
            metadata.merkle_proofs_validated = self
                .validate_merkle_proofs(claim, bundle, &mut metadata, &mut errors)
                .await?;
        }

        // Verify claim against bundle data
        if let Some(ref claim) = claim {
            metadata.claim_verification_successful = self
                .verify_claim_against_bundle(claim, bundle, &mut errors)
                .await?;
        }

        metadata.validation_time_ms = start_time.elapsed().as_millis() as u64;

        let is_valid = errors.is_empty() && claim.is_some();
        
        info!(
            "ZK proof validation completed: valid={}, platform={}, time_ms={}",
            is_valid, platform, metadata.validation_time_ms
        );

        Ok(ZkProofValidationResult {
            is_valid,
            claim,
            metadata,
            errors,
        })
    }

    /// Validate RISC0 proof
    #[cfg(feature = "risc0")]
    #[instrument(skip(self, proof_data, metadata, errors))]
    async fn validate_risc0_proof(
        &self,
        proof_data: &[u8],
        bundle: &VefasCanonicalBundle,
        metadata: &mut ZkProofValidationMetadata,
        errors: &mut Vec<String>,
    ) -> VefasNodeResult<Option<VefasProofClaim>> {
        debug!("Validating RISC0 proof");

        // Deserialize VEFAS RISC0 proof
        let risc0_proof: vefas_risc0::VefasRisc0Proof = bincode::deserialize(proof_data)
            .map_err(|e| {
                let error_msg = format!("Failed to deserialize VEFAS RISC0 proof: {}", e);
                error!("{}", error_msg);
                errors.push(error_msg.clone());
                VefasNodeError::ProofVerificationFailed(error_msg)
            })?;

        // Verify the proof using VEFAS RISC0 prover
        if let Some(ref prover) = self.risc0_prover {
            let verified_claim = prover.verify_proof(&risc0_proof)
                .map_err(|e| {
                    let error_msg = format!("RISC0 proof verification failed: {:?}", e);
                    error!("{}", error_msg);
                    errors.push(error_msg.clone());
                    VefasNodeError::ProofVerificationFailed(error_msg)
                })?;

            debug!("RISC0 proof verification passed");
            metadata.claim_extraction_successful = true;
            Ok(Some(verified_claim))
        } else {
            let error_msg = "RISC0 prover not initialized".to_string();
            error!("{}", error_msg);
            errors.push(error_msg.clone());
            Err(VefasNodeError::ProofVerificationFailed(error_msg))
        }
    }

    /// Validate SP1 proof
    #[cfg(feature = "sp1")]
    #[instrument(skip(self, proof_data, metadata, errors))]
    async fn validate_sp1_proof(
        &self,
        proof_data: &[u8],
        bundle: &VefasCanonicalBundle,
        metadata: &mut ZkProofValidationMetadata,
        errors: &mut Vec<String>,
    ) -> VefasNodeResult<Option<VefasProofClaim>> {
        debug!("Validating SP1 proof");

        // Deserialize VEFAS SP1 proof
        let sp1_proof: vefas_sp1::VefasSp1Proof = bincode::deserialize(proof_data)
            .map_err(|e| {
                let error_msg = format!("Failed to deserialize VEFAS SP1 proof: {}", e);
                error!("{}", error_msg);
                errors.push(error_msg.clone());
                VefasNodeError::ProofVerificationFailed(error_msg)
            })?;

        // Verify the proof using VEFAS SP1 prover
        if let Some(ref prover) = self.sp1_prover {
            let verified_claim = prover.verify_proof(&sp1_proof)
                .map_err(|e| {
                    let error_msg = format!("SP1 proof verification failed: {:?}", e);
                    error!("{}", error_msg);
                    errors.push(error_msg.clone());
                    VefasNodeError::ProofVerificationFailed(error_msg)
                })?;

            debug!("SP1 proof verification passed");
            metadata.claim_extraction_successful = true;
            Ok(Some(verified_claim))
        } else {
            let error_msg = "SP1 prover not initialized".to_string();
            error!("{}", error_msg);
            errors.push(error_msg.clone());
            Err(VefasNodeError::ProofVerificationFailed(error_msg))
        }
    }


    /// Validate Merkle proofs for selective disclosure
    #[instrument(skip(self, metadata, errors))]
    async fn validate_merkle_proofs(
        &self,
        _claim: &VefasProofClaim,
        bundle: &VefasCanonicalBundle,
        metadata: &mut ZkProofValidationMetadata,
        errors: &mut Vec<String>,
    ) -> VefasNodeResult<bool> {
        debug!("Validating Merkle proofs for selective disclosure");

        if bundle.merkle_proofs.is_empty() {
            let error_msg = "No Merkle proofs available in bundle".to_string();
            warn!("{}", error_msg);
            errors.push(error_msg);
            return Ok(false);
        }

        let mut valid_proofs = 0;
        let total_proofs = bundle.merkle_proofs.len();

        // Validate each Merkle proof
        for (field_id, proof_data) in &bundle.merkle_proofs {
            match self.validate_single_merkle_proof(*field_id, proof_data, bundle, errors).await {
                Ok(true) => {
                    valid_proofs += 1;
                    debug!("Merkle proof validation passed for field_id: {}", field_id);
                }
                Ok(false) => {
                    let error_msg = format!("Merkle proof validation failed for field_id: {}", field_id);
                    warn!("{}", error_msg);
                    errors.push(error_msg);
                }
                Err(e) => {
                    let error_msg = format!("Merkle proof validation error for field_id {}: {}", field_id, e);
                    error!("{}", error_msg);
                    errors.push(error_msg);
                }
            }
        }

        metadata.merkle_proofs_count = valid_proofs;
        let all_valid = valid_proofs == total_proofs;

        info!(
            "Merkle proof validation completed: {}/{} proofs valid",
            valid_proofs, total_proofs
        );

        Ok(all_valid)
    }

    /// Validate a single Merkle proof
    async fn validate_single_merkle_proof(
        &self,
        field_id: u8,
        proof_data: &[u8],
        bundle: &VefasCanonicalBundle,
        _errors: &mut Vec<String>,
    ) -> VefasNodeResult<bool> {
        use vefas_crypto::FieldId;

        // Deserialize Merkle proof
        let merkle_proof: vefas_crypto::MerkleProof = bincode::deserialize(proof_data)
            .map_err(|e| {
                let error_msg = format!("Failed to deserialize Merkle proof for field_id {}: {}", field_id, e);
                VefasNodeError::ProofVerificationFailed(error_msg)
            })?;

        // Convert field_id to enum
        let field_id_enum = self.field_id_to_enum(field_id)?;

        // Get the expected leaf value for this field
        let expected_leaf_value = self.get_expected_leaf_value(field_id, bundle)?;

        // Verify the Merkle proof using vefas-crypto trait
        let is_valid = self.verify_merkle_proof(&merkle_proof, &expected_leaf_value, &bundle.merkle_root, field_id_enum)?;

        Ok(is_valid)
    }

    /// Convert numeric field ID to FieldId enum
    fn field_id_to_enum(&self, field_id: u8) -> VefasNodeResult<vefas_crypto::FieldId> {
        use vefas_crypto::FieldId;

        match field_id {
            1 => Ok(FieldId::HttpRequest),
            2 => Ok(FieldId::HttpResponse),
            3 => Ok(FieldId::Domain),
            4 => Ok(FieldId::Timestamp),
            10 => Ok(FieldId::HandshakeProof),
            11 => Ok(FieldId::TlsVersion),
            _ => Err(VefasNodeError::InvalidRequest(
                format!("Unknown field ID: {}", field_id)
            )),
        }
    }

    /// Get expected leaf value for a field ID
    fn get_expected_leaf_value(
        &self,
        field_id: u8,
        bundle: &VefasCanonicalBundle,
    ) -> VefasNodeResult<Vec<u8>> {
        use vefas_crypto::FieldId;

        let field_id_enum = match field_id {
            1 => FieldId::HttpRequest,
            2 => FieldId::HttpResponse,
            3 => FieldId::Domain,
            4 => FieldId::Timestamp,
            10 => FieldId::HandshakeProof,
            11 => FieldId::TlsVersion,
            _ => {
                return Err(VefasNodeError::InvalidRequest(
                    format!("Unknown field ID: {}", field_id)
                ));
            }
        };

        match field_id_enum {
            FieldId::HttpRequest => Ok(bundle.http_request.clone()),
            FieldId::HttpResponse => Ok(bundle.http_response.clone()),
            FieldId::Domain => Ok(bundle.domain.as_bytes().to_vec()),
            FieldId::Timestamp => Ok(bundle.timestamp.to_be_bytes().to_vec()),
            FieldId::HandshakeProof => {
                // Build HandshakeProof from bundle data
                let handshake_proof = vefas_crypto::bundle_parser::build_handshake_proof(bundle)
                    .map_err(|e| VefasNodeError::ProofVerificationFailed(format!("Failed to build HandshakeProof: {:?}", e)))?;
                Ok(handshake_proof.to_bytes()
                    .map_err(|e| VefasNodeError::ProofVerificationFailed(format!("Failed to serialize HandshakeProof: {:?}", e)))?)
            }
            FieldId::TlsVersion => Ok(bundle.tls_version.to_be_bytes().to_vec()),
        }
    }

    /// Verify a Merkle proof using vefas-crypto unified traits
    ///
    /// This function uses the production-grade MerkleVerifier trait from vefas-crypto,
    /// which ensures consistent Merkle verification across host and guest environments.
    ///
    /// # Benefits of using the trait:
    /// - Consistent domain separation (DOMAIN_SEP_LEAF = 0x01, DOMAIN_SEP_NODE = 0x02)
    /// - Proper field ID encoding
    /// - Can leverage zkVM precompiles when available
    /// - Eliminates code duplication
    fn verify_merkle_proof(
        &self,
        proof: &vefas_crypto::MerkleProof,
        leaf_value: &[u8],
        merkle_root: &[u8; 32],
        field_id: vefas_crypto::FieldId,
    ) -> VefasNodeResult<bool> {
        use vefas_crypto_native::NativeCryptoProvider;
        use vefas_crypto::MerkleVerifier;

        // Create crypto provider
        let crypto_provider = NativeCryptoProvider::new();

        // Use the unified MerkleVerifier trait - handles all domain separation correctly
        let is_valid = crypto_provider
            .verify_inclusion_proof(merkle_root, proof, field_id, leaf_value)
            .map_err(|e| {
                VefasNodeError::ProofVerificationFailed(format!(
                    "Merkle verification failed for field {:?}: {:?}",
                    field_id, e
                ))
            })?;

        if is_valid {
            info!("Merkle proof verification passed for field: {:?}", field_id);
        } else {
            warn!("Merkle proof verification failed for field: {:?}", field_id);
        }

        Ok(is_valid)
    }

    /// Verify claim against bundle data
    #[instrument(skip(self, claim, errors))]
    async fn verify_claim_against_bundle(
        &self,
        claim: &VefasProofClaim,
        bundle: &VefasCanonicalBundle,
        errors: &mut Vec<String>,
    ) -> VefasNodeResult<bool> {
        debug!("Verifying claim against bundle data");

        let mut validations_passed = 0;
        let mut total_validations = 0;

        // Verify domain matches
        total_validations += 1;
        if claim.domain == bundle.domain {
            validations_passed += 1;
            debug!("Domain verification passed: {}", claim.domain);
        } else {
            let error_msg = format!("Domain mismatch: claim={}, bundle={}", claim.domain, bundle.domain);
            warn!("{}", error_msg);
            errors.push(error_msg);
        }

        // Verify timestamp matches
        total_validations += 1;
        if claim.timestamp == bundle.timestamp {
            validations_passed += 1;
            debug!("Timestamp verification passed: {}", claim.timestamp);
        } else {
            let error_msg = format!("Timestamp mismatch: claim={}, bundle={}", claim.timestamp, bundle.timestamp);
            warn!("{}", error_msg);
            errors.push(error_msg);
        }

        // Verify certificate fingerprint matches
        total_validations += 1;
        if claim.cert_fingerprint == bundle.cert_fingerprint {
            validations_passed += 1;
            debug!("Certificate fingerprint verification passed");
        } else {
            let error_msg = "Certificate fingerprint mismatch".to_string();
            warn!("{}", error_msg);
            errors.push(error_msg);
        }

        // Verify TLS version matches
        total_validations += 1;
        let expected_tls_version = match bundle.tls_version {
            0x0303 => "1.2",
            0x0304 => "1.3",
            _ => "unknown",
        };
        if claim.tls_version == expected_tls_version {
            validations_passed += 1;
            debug!("TLS version verification passed: {}", claim.tls_version);
        } else {
            let error_msg = format!("TLS version mismatch: claim={}, expected={}", claim.tls_version, expected_tls_version);
            warn!("{}", error_msg);
            errors.push(error_msg);
        }

        let all_valid = validations_passed == total_validations;

        info!(
            "Claim verification completed: {}/{} validations passed",
            validations_passed, total_validations
        );

        Ok(all_valid)
    }
}

impl Default for VerifierService {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Debug for VerifierService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VerifierService")
            .field("risc0_prover", &self.risc0_prover.is_some())
            .field("sp1_prover", &self.sp1_prover.is_some())
            .finish()
    }
}
